---
title: 八股
description: 教会你如何成为java领域大神
published: 2025-09-07
tags: [Java,八股]
category: 八股
draft: false
---

## 📌 问题
- 面向对象三大特性？
- 接口 抽象类？
- 静态变量和成员变量的区别？
- ArrayList LinkedList？
- HashMap？
## 🧩 答案
- 封装 继承 多态
封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过对外公开的接口。通过这种方式，对对象内部数据提供不同程度的保护，以防止程序中无关部分意外的改变，或错误的使用对象的私有部分。
继承：让某个类型的对象获得另一个对象的属性和方法，子类继承父类的特征和行为。
多态：底层实现是动态绑定，即运行时才将方法调用和方法关联起来
编译时多态 方法重载
运行时多态 方法的重写和接口的绑定
多态的实现过程，就是方法调用动态分派的过程。如果子类覆盖了父类的方法，则在动态调用中，动态绑定过程会首先确定实际类型是子类，从而搜索到子类的方法。

- 接口和抽象类的共同点
实例化：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对
象。
抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。

- 接口和抽象类的区别
设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用
于代码复用，强调的是所属关系。
继承和实现：一个类只能继承一个类（包括抽象类），因为Java不支持多继承。但一个类可以实现多个
接口，一个接口也可以继承多个其他接口。
成员变量：接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值。
抽象类的成员变量可以有任何修饰符（private，protected，public)，可以在子类中被重新定义或赋值。

- 静态变量存放于方法区中，随着类的创建而创建，随着类的销毁而销毁，既能被对象调用，又能被类调用。
成员变量存放于堆内存中，随着对象的创建而创建，随着对象的销毁而销毁，只能被对象调用

- ● 底层实现：ArrayList基于动态数组实现，而LinkedList基于双向链表实现。
● 随机访问：ArrayList在随机访问时效率更高，因为它支持通过索引直接访问元素，而LinkedList需要遍历链表。
● 插入和删除：在插入和删除操作上，LinkedList更优，因为它只需调整节点的引用，而ArrayList可能需要移动数组中的元素。
● 内存占用：LinkedList的每个节点除了存储数据外，还需要存储两个引用（指向前后节点），因此它比ArrayList占用更多内存。
● 使用场景：如果需要频繁插入和删除操作，使用LinkedList更合适；如果需要频繁随机访问，使用ArrayList更合适。


## 🧩 HashMap
- 1.hashmap是什么？
hashmap是java常用的键值对的集合结构，键唯一，值可重复，基于哈希表实现，查找平均O（1）的时间复杂度
- 2.hashmap底层结构是什么？
数组加链表加红黑树，数组是主体，链表和红黑树是用来解决哈希冲突的
- 3.为什么既要红黑树又要链表？
jdk1.7之前只有链表，jdk1.8开始，如果链表太长就转化为红黑树，因为红黑树能够将最坏情况下的查找复杂度从O(n)降低到O(logn)
- 4.为什么要红黑树不要AVL树
因为AVL树是严格平衡的，二叉树维护代价比较高，而红黑树平衡策略相对宽松，是实际工程中的最佳折中实践
- 5.红黑树这么厉害，为什么还留着链表？
红黑树相比链表需要占用更多的内存，红黑树节点大小是普通节点大小的两倍，能省即省
- 6.链表什么时候转成红黑树？
链表长度大于等于8，数组容量大于等于64
- 7.为什么数组要大于等于64？
主要是为了避免频繁的树化和减少内存占用。数组容量小的时候，扩容自然会减少哈希冲突，且容量小的时候更容易扩容，过早的树化可能立马又扩容了，那就白树化了。减少内存（上面提到的红黑树节点大小是普通节点大小的两倍）
- 8.为什么是8
和泊松分布有关，因为红黑树占用内存大，能不用就不用，在默认负载因子0.75下，链表冲突刚好到8的几率其实很低，基本上不会触发，所以这其实是时间效率和空间占用之间的平衡
- 9.如果链表转化为红黑树，还会转回来吗？
当树节点小于等于6
- 10.为什么是6？
缓冲余地，避免反复树化和反树化带来的开销
- 11.为什么默认负载因子是0.75？
时间和空间的平衡，0.5冲突小查的快 1.0省空间但查的慢
- 12.put的流程
计算哈希，选择bucket。若空则插入，若非空则检查equals（），选择替换还是插入到尾部。还会根据阈值决定树化或扩容
- 13.插入到尾部？为什么不是插入到头部？
jdk1.7用的是头插法，多线程同时执行可能会导致链表成环，导致死循环
- 14.尾插法就不会成环了吗？
会，本就不该在多线程环境下使用hashmap
- 15.hashmap扩容机制
hashmap默认初始容量是16，负载因子是0.75，因此默认扩容阈值是12，理论上插入第13个元素就会扩容，扩容就是新建一个两倍大小的新数组，把原来的元素重新hash迁移过去
- 16.为什么是两倍？
因为容量始终保持2的幂看，这样可以通过（n-1）&hash这个位运算快速定位到数组下标，比直接取余运算效率高很多
